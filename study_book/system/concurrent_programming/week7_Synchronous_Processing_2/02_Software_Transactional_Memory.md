# 2. Software Transactional Memory

- 락 알고리즘 (비관적 락)
  - 락을 획득하지 않으면 크리티컬 세션 안의 코드는 수행하지 않는 배타 제어 방법
- 트랜잭셔널 메모리 (낙관적 락)
  - 코드를 투기적으로 실행(??)
  - 경합이 감지되지 않았을때 메모리에 결과를 커밋
  - 크리티컬 세션을 트랜잭션이라 부름
  - 하드웨어나 소프트웨어로 구현 가능
    - 소프트웨어: STM 구현 방식 중 하나인 TL2의 알고리즘을 살펴봄


## 1. Software Transactional Memory
### 특징
#### 트랜잭션 중의 코드가 2회 이상 실행될 가능성이 있다
| 유형                  | 예시                                    | 왜 문제인가?                                 |
| ------------------- | ------------------------------------- | --------------------------------------- |
| 1. **외부 입출력 (I/O)** | 파일 쓰기, 로그 출력, DB 업데이트, 네트워크 전송        | 반복 실행 시 **중복 효과 발생** (e.g., 두 번 메일 발송됨) |
| 2. **시간 의존 코드**     | `SystemTime::now()`, `rand()`         | 재실행마다 값이 달라져 **불일치 발생**                 |
| 3. **전역 상태 변경**     | 전역 변수 증가, 카운터 누적, static 값 수정         | **idempotent하지 않음**, 중복 상태 반영           |
| 4. **락 획득 및 해제**    | `mutex.lock()`, `semaphore.acquire()` | 락 중복 획득 → 데드락 위험                        |
| 5. **신호 보내기 / 알람**  | event trigger, interrupt 발생, 신호 전송    | 동일 신호를 **여러 번 발신**할 수 있음                |
| 6. **메모리 할당/해제**    | malloc/free, Box::new(), drop()       | 리소스 누수 또는 double-free 발생 가능             |
| 7. **디바이스 접근**      | 센서 읽기, 하드웨어 컨트롤                       | 실제 장치의 상태를 오염시킬 수 있음                    |

#### 트랜잭션 중에 부작용이 있는 코드는 실행하지 않는다
#### 데드락이 발생하지 않는다
- STM은 투기적으로 실행한 후 경합을 감시함
- 경합이 발견된 후에는 트랜잭션을 재시도하므로 2회 이상 실행될 가능성이 있음
- 실행 횟수가 중요한 함수인 경우 부작용을 주의해야 함 (특히 외부와의 IO)
  - 복원이 필요함
  - 재시도를 거듭하면서 커밋을 하지 않는 Starvation 가능
    - 재시도가 많은 경우 동기 실행하는 프로세스를 제한하는 방법으로 workaround 가능

#### 여러 트랜잭션 처리를 합성할 수 있다. 
- STM에서는 여러 atomic 블록을 조합해서 새로운 트랜잭션을 쉽게 만들 수 있음.

## 2. TL2 Algorithm
  구현 참조
  
### 주안점
- write Transaction
  - read-version : global version-clock을 read-version에 복사
  - 투기적 실행
    - write-set에 쓸 대상 주소와 데이터 저장, 실제로는 쓰지 않음
    - write-set -> 메모리 순으로 읽음
    - 기타 read Transaction과 동일
  - write-set 락 획득
  - global version-clock 증가
  - read-set 검증
    - 투기적 실행과 검증 과정 동일
    - 단, read-version+1 = write-version인 경우에는 이 확인을 건너뛸 수 있음
    - 그 사이에 write가 없었고, 
    - 현재 write 트랜잭션이 write-set을 이미 락으로 보호 중
  - 커밋과 릴리즈 
- read Transaction
  - read-version : global version-clock을 read-version에 복사
  - 투기적 실행
    - 메모리 읽기 전후로 대상 스트라이프가 락 되어 있는지
    - 스트라이프 버전이 read-version보다 낮은지 -> `test_not_modify()`



- LL/SC vs STM


**LL/SC (Load-Linked / Store-Conditional)**와 **STM (Software Transactional Memory)**은 둘 다 동시성 제어를 위한 기법이지만,
철학과 구현 방식이 근본적으로 다릅니다. 아래에 비교 분석해드리겠습니다.

🧠 TL;DR

| 항목     | **LL/SC**              | **STM**                       |
| ------ | ---------------------- | ----------------------------- |
| 핵심 개념  | 단일 변수의 **원자적 수정 시도**   | 여러 변수에 대한 **트랜잭션 단위 변경**      |
| 목적     | 락 없는 단일 객체 업데이트        | 락 없는 복수 객체 일관성 유지             |
| 충돌 감지  | **하드웨어 수준에서 감지**       | **소프트웨어에서 read/write set 추적** |
| 실패 조건  | 다른 쓰기가 있으면 SC 실패       | 트랜잭션 중 다른 쓰기 발생 시 전체 abort    |
| 재시도 비용 | 낮음 (짧은 retry loop)     | 높음 (트랜잭션 재실행 전체)              |
| 구성 범위  | **하나의 주소**만 추적 가능      | **다수 주소들** 추적 가능              |
| 구현     | 하드웨어 제공 (특수 명령어)       | 언어나 라이브러리 수준에서 구현 가능          |
| 사용 예   | lock-free stack, queue | 고수준 병행 컨테이너, STM 라이브러리        |



