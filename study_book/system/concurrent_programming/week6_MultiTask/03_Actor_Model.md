# 3. Actor Model
- 목적 : 동시성과 병렬성을 효율적으로 다루기 위해 고안된 프로그래밍 모델
-  액터(Actor)는 독립적인 실행 단위
  - 자기만의 상태를 가지고 있음
  - 외부와의 상호 작용은 오직 메시지를 통해서만 이루어 짐
- 대기 스레드 <-> 실행 큐로 이동하며 컨텍스트를 이동
- Actor Model 패턴에서 Actor 개념과 객체지향 언어에서의 객체 개념은 상당히 유사
  - 단지 다른 점이 있다면 객체지향에서의 메소드 호출은 메소드가 모두 실행될 때까지 기다려야 하는 동기식이다. 
- 반면 Actor Model 패턴에서의 다른 Actor에 대한 메시지 전송은 기본적으로 비동기식이다.
  - 이 비동기식 메시지 전송을 지원하기 위해서는 Actor들이 모두 Active 객체, 즉 쓰레드 기반으로 동작하는 객체여야 하고, 메시지의 전송/수신에 대한 동기화 관리가 이루어 져야 한다.
  - 동기화 부분은 Actor 내부에 있는 Mailbox라는 객체를 통해서 해결되기 때문에 Actor들을 구현하는데 있어서는 동기화에 대한 고려를 전혀 하지 않아도 된다. 
  
출처: https://effectiveprogramming.tistory.com/entry/Actor-Model-패턴의-구현Java [Effective Programming:티스토리]


##  구현 시 주의사항 (Generated by chatGPT)
-  데드락: 서로 응답 대기
-  무한 메시지 루프: 메시지 순환
-  메일박스 과부하: 큐가 터짐
-  공유 자원 접근: 동기화 누락
-  실패 복구: supervisor 없이 죽으면 끝
-  메모리 누수: 순환 참조, 정리 안 됨

### 질의응답 
- 이벤트 기반이랑 뭐가 다른거지?

| 항목         | **이벤트 기반(Event-driven)** | **액터 모델(Actor model)**            |
| ---------- | ------------------------ | --------------------------------- |
| **단위**     | 함수, 핸들러                  | 액터 (객체처럼 독립된 주체)                  |
| **상태**     | 전역 상태 or 공유 객체           | 액터 내부에 캡슐화                        |
| **메시지 처리** | 이벤트 루프가 핸들러 호출           | 액터 큐에 메시지 → 1개씩 처리                |
| **동시성 처리** | 수동 동기화 필요 (락 등)          | 상태 공유 안함 → 락 없이 안전                |
| **실행 흐름**  | 콜백 / 핸들러 기반 (flat)       | 메시지를 기반으로 한 구조적 흐름 (tree-like 가능) |
| **에러 처리**  | 수동 try-catch, 복구는 개발자 책임 | supervisor 구조 존재 (자동 복구 모델 존재)    |


- 액터 모델은 state가 잘 작성되었다는 가정이 필요한데, 이는 어떻게 보장되지?

| 보장 요소                      | 역할                   |
| -------------------------- | -------------------- |
| **언어 레벨 캡슐화**              | 외부 접근 차단 (private 등) |
| **메시지 기반 인터페이스**           | 상태 접근을 정해진 루트로만 허용   |
| **단일 메시지 처리**              | 내부 상태에 대한 동시 접근 제거   |
| **프레임워크 제약 (Akka, Actix)** | 상태 접근 방식 강제          |
| **Supervisor / 테스트 유도**    | 상태 오류 감지 및 복구 설계 가능  |


