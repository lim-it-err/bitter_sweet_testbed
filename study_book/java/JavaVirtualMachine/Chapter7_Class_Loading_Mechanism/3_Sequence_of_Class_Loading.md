# 3. 클래스 로딩 처리 과정
> 로딩 -> 검증 -> 준비 -> 해석 -> 초기화
## 3.1. 로딩
1. 완전한 이름을 보고 클래스의 바이너리 바이트 스트림을 가져옴.
   - 위치나 읽어오는 방법 명시 X : 개방적이고 광범위함
2. 바이트 스트림으로 표현된 정적인 정적 구조를 메서드 영역에서 사용하는 런타임 데이터 구조로 변환.
3. 로딩 대상 클래스를 표현하는 java.lang.Class 객체를 힙 메모리에 생성

이외에는 구체적으로 명시하지 않았기 때문에 다양한 방법으로 스트리밍을 로드 할 수 있게 되었다.
- ZIP : 이후 JAR, EAR, WAR 파일의 기초가 됨
- 네트워크 : 웹 애플릿
- 런타임 동적 생성
- 다른 파일로부터 생성 : JSP emd
- 데이터베이스로부터 로딩 : 클러스터 배포 시 (SAP 넷위버)
- 암호화된 파일로부터의 로딩

ClassLoader 의 `findClass()` 혹은 `loadClass()` 메서드를 오버라이딩하면 바이트 스트리밍을 받는 방법을 통제할 수 있음

단, 배열 클래스는 클래서 로더가 생성하지 않고, 자바 가상 머신이 직접 메모리에 동적으로 생성
>자바의 배열 타입은 JVM이 직접 생성하며, 사용자 정의 ClassLoader가 이를 로딩하지 않습니다.</br>
>즉, String[], int[], User[] 같은 배열 클래스는 MyCustomClassLoader.findClass()로 로딩되지 않아요.</br>
>이 배열 클래스들은 JVM 내부적으로 자동 생성되며, 명시적으로 .class 파일이 존재하지 않습니다.</br>
>그래서 우리가 ClassLoader를 통해 바이트 스트림에서 클래스 정의를 직접 읽는 과정(findClass) 을 거쳐도, 배열은 그 대상이 아닙니다.


| 타입                                 | 설명                       | 누가 생성/관리하나                               |
| ---------------------------------- | ------------------------ | ---------------------------------------- |
| `int`, `boolean`, `void` 등 (기본형)   | `.class` 파일이 없음          | JVM이 직접 관리 (`int.class`, `void.class` 등) |
| `int[]`, `String[]`, `User[]` (배열) | 배열 클래스는 `.class` 존재하지 않음 | JVM이 런타임 시 자동 생성                         |
| `MyClass`                          | 일반 사용자 정의 클래스            | `ClassLoader`가 로딩                        |
| `Object`, `String`, `Integer` 등    | JDK 내장 클래스               | 부트스트랩(bootstrap) ClassLoader             |

즉, 재귀적으로 생성

## 3.2. 검증, 링킹 과정 중 첫 번째
- 가상 머신 명세에서 규정한 제약을 만족했는지 확인-> 보안 위협 확인
특히, 바이트 스트림 자체를 규정해야 하는 경우
Java SE7을 걸쳐 4단계로 진행함을 규정

1. 파일 형식 검증
   - 매직 넘버로 시작하는가?
   - 메이저 버전, 마이너 버전, 상수 플래그 등 형태 확인
