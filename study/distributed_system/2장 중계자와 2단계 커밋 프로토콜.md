# 2장. 중계자와 2단계 커밋 프로토콜

Owner: 임정한

중계자를 둠.

# 2.1. 계좌 이체 문제

T1 : A = A - 10 if A≥10

T2 : B = B + 10

# 2.2 안정성과 라이브니스

안정성 : 잘못된 결과가 일어나서는 안 되는 원칙

라이브니스 : 어느 시점에서는 실현되어야 하는 원칙

- 의견
    - ACID에서의 해석
        - 안정성 : A, C
        - 라이브니스 :
    - CAP 에서의 해석 (제 의견)
        - 안정성 : C
        - 라이브니스 : A, P
    

Commit : 각 노드 합의에 따른 해당 노드의 결정. → 모든 노드가 Commit할 경우 “라이브니스” 충족

각 노드 합의의 예시

### 스트로우맨 프로토콜

**역할/ 의의 : 동참할 수 있는 지 여부를 확인한 후, 조건이 될 때 수행한다. (commit 상태 구성)**

<aside>
💬 T1: (요청을 잘 전달했습니다)
       A = A - 10 if A≥10

T2: B = B + 10

</aside>

**문제가 발생할 수 있는 상황**

- T1, T2가 이 수행에 실패한 경우
    - A 계좌 잔액 부족, B 읽기 불가
        - A, B의 작업 적합성 선 판단
    - T1에서 첫 쿼리만 수행된 경우
        - T2, 혹은 TC에서 상태 참고
- T1 혹은 T2 중 하나 이상이 partial commit → 커밋에 실패한 경우
    - T2 네트워크 실패
    - TC 실패

→ 이를 보완한 프로토콜

1. 수행 전 디스크에 데이터를 작성한다.
2. TC에서 현재 상태를 확인한다.
3. TC가 무응답 시 다른 은행(프로세서)를 참고한다.

![1000000176.jpg](2%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A8%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%AA%202%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8F%E1%85%A5%E1%84%86%E1%85%B5%E1%86%BA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%20b1dd43a11d2e4760a424c5a648187d00/1000000176.jpg)

문제가 발생할 수 있는 상황

1. 이웃 은행이 응답을 받지 않는경우
    
    → TC, 이웃 프로세서 모두 연결 실패
    
2. 참조한 은행의 상태가 변경 전일 경우
    1. 순간적으로 consistency가 무너진 경우
        1. 특히, 네트워크가 불안정하여 latency가 늘어난 경우
    2. 특정 시간 동안 상태 변경 여부 확인 필요 
    

## 2단계 커밋 프로토콜

> 여러 서비스 간의 트랜잭션이 일관되게 처리되도록 설계하는 방법
> 

<aside>
💬 **가정**
프로토콜은 다음과 같은 방식으로 작동합니다. 한 노드는 마스터 사이트인 지정된 코디네이터이고 네트워크의 나머지 노드는 참가자로 지정됩니다. 프로토콜은 다음을 가정합니다.
1. 각 노드에는 [미리 쓰기 로그 가 있는](https://en.wikipedia.org/wiki/Write_ahead_logging) [안정적인 저장소가](https://en.wikipedia.org/wiki/Stable_storage) 있습니다 .
2. 노드가 영원히 충돌하지 않습니다.
**3. 미리 쓰기 로그의 데이터는 충돌 시 손실되거나 손상되지 않습니다. → Participant의 예외처리가 없음.**
4. 두 노드는 서로 통신할 수 있습니다.

</aside>

![[https://www.alibabacloud.com/blog/tech-insights---two-phase-commit-protocol-for-distributed-transactions_597326](https://www.alibabacloud.com/blog/tech-insights---two-phase-commit-protocol-for-distributed-transactions_597326)](2%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A8%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%AA%202%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8F%E1%85%A5%E1%84%86%E1%85%B5%E1%86%BA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%20b1dd43a11d2e4760a424c5a648187d00/Untitled.png)

[https://www.alibabacloud.com/blog/tech-insights---two-phase-commit-protocol-for-distributed-transactions_597326](https://www.alibabacloud.com/blog/tech-insights---two-phase-commit-protocol-for-distributed-transactions_597326)

### **1. 준비(Prepare) 단계**

- **코디네이터의 역할**: 트랜잭션을 관리하는 코디네이터는 참여하는 모든 데이터베이스 또는 노드(참여자)에게 트랜잭션 커밋 준비를 요청합니다. 이는 '준비 요청' 메시지를 보내는 것을 포함합니다.
- **참여자의 반응**: 각 참여자는 트랜잭션을 커밋할 수 있는지 검토한 후, 준비 완료(YES) 또는 준비 실패(NO) 응답을 코디네이터에게 보냅니다. 준비 완료 응답을 보내기 전에, 참여자는 모든 필요한 정보를 로그에 기록하여 시스템이 충돌해도 트랜잭션을 복구할 수 있도록 합니다.

### **2. 커밋(Commit) 단계**

- **모든 참여자의 준비 완료**: 코디네이터가 모든 참여자로부터 준비 완료 응답을 받으면, '커밋' 명령을 보내 트랜잭션을 완료하도록 합니다. 각 참여자는 커밋 명령을 받은 후 트랜잭션을 커밋하고, 성공적으로 커밋되었음을 코디네이터에게 알립니다.
- **준비 실패 응답이 있는 경우**: 만약 어떤 참여자라도 준비 실패 응답을 보냈다면, 코디네이터는 모든 참여자에게 '롤백' 명령을 보냅니다. 참여자들은 트랜잭션을 롤백하고, 롤백이 완료되었음을 코디네이터에게 알립니다.

### 예외 처리

- Coordinator가 무응답인 경우
    - 이웃 서버/노드의 로그 확인.
    
    ![스크린샷 2024-05-12 오전 9.29.11.png](2%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A8%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%AA%202%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8F%E1%85%A5%E1%84%86%E1%85%B5%E1%86%BA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%20b1dd43a11d2e4760a424c5a648187d00/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-05-12_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_9.29.11.png)
    
    - 질문
        
        만약 commit에 실패할 경우에 대비해서, Lock은 언제 해제해야 하나
        
    - 노드가 많을 경우?
        - 트리 형태로 통신을 구성함, Recursive 2PC
        - 질문
            
            Tree 형태는 네트워크 가용성으로부터 자유로운가? Mesh 형태가 낫지 않은지?
            
            ![Untitled](2%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A8%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%AA%202%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8F%E1%85%A5%E1%84%86%E1%85%B5%E1%86%BA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%20b1dd43a11d2e4760a424c5a648187d00/Untitled%201.png)
            
        
        ![스크린샷 2024-05-12 오전 9.29.57.png](2%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A8%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%AA%202%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8F%E1%85%A5%E1%84%86%E1%85%B5%E1%86%BA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%20b1dd43a11d2e4760a424c5a648187d00/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-05-12_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_9.29.57.png)
        
- Participant가 무응답인 경우
    - 해당 테스크를 취소하고, 이후 들어오는 결과값에 취소로 대응.
    
    ![스크린샷 2024-05-12 오전 9.27.58.png](2%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A8%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%AA%202%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%8F%E1%85%A5%E1%84%86%E1%85%B5%E1%86%BA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%20b1dd43a11d2e4760a424c5a648187d00/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-05-12_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_9.27.58.png)